<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[think more]]></title>
  <link href="neillee1991.github.io/atom.xml" rel="self"/>
  <link href="neillee1991.github.io/"/>
  <updated>2018-08-15T20:43:37+08:00</updated>
  <id>neillee1991.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="neillee1991.github.io/15343369063361.html"/>
    <updated>2018-08-15T20:41:46+08:00</updated>
    <id>neillee1991.github.io/15343369063361.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[THE VERY BASIC]]></title>
    <link href="neillee1991.github.io/15341698542806.html"/>
    <updated>2018-08-13T22:17:34+08:00</updated>
    <id>neillee1991.github.io/15341698542806.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>这里用来记录一些Python中最基础的东西</p>
</blockquote>

<h5 id="toc_0">中文编码</h5>

<p>Python中默认的编码格式是ASCII格式，所以打印汉字时要在文件开头声明编码。</p>

<pre><code class="language-python"># -*- coding: UTF-8 -*- 
或者
#coding=utf-8
</code></pre>

<h5 id="toc_1">import的搜索路径</h5>

<ol>
<li>当前目录</li>
<li>PYTHONPATH下的每个目录</li>
<li>默认路径，UNIX下，一般为<code>/usr/local/lib/python/</code></li>
</ol>

<h5 id="toc_2">namespace</h5>

<p>Python假设任何在函数内赋值的变量都是局部的，因此给函数内的全局变量赋值，必须使用<code>global</code>语句</p>

<h5 id="toc_3">reload()函数</h5>

<p>当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。</p>

<p>因此，如果你想重新执行模块里顶层部分的代码，可以用 <code>reload()</code>函数。该函数会重新导入之前导入过的模块，这样就允许在不退出解释器的情况下重新加载已更改的Python模块。</p>

<h5 id="toc_4">包的结构</h5>

<p>包中必须存在 <code>__init__.py</code> 文件, 该文件的内容可以为空。<code>__init__.py</code> 用于标识当前文件夹是一个包。</p>

<h5 id="toc_5">IO</h5>

<p><code>raw_input([prompt])</code> 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）</p>

<pre><code class="language-python">str = raw_input(&quot;请输入：&quot;)
print &quot;你输入的内容是: &quot;, str
------------------------------
&gt;&gt;请输入：Hello Python！
&gt;&gt;你输入的内容是:  Hello Python！
</code></pre>

<p><code>input([prompt])</code>和 <code>raw_input([prompt])</code> 基本类似，但是 input 可以接收一个Python表达式作为输入，并将运算结果返回。</p>

<pre><code class="language-python">str = input(&quot;请输入：&quot;)
print &quot;你输入的内容是: &quot;, str
------------------------------
&gt;&gt;请输入：[x*5 for x in range(2,10,2)]
&gt;&gt;你输入的内容是:  [10, 20, 30, 40]
</code></pre>

<h5 id="toc_6">私有方法、属性</h5>

<ul>
<li><code>__private_attrs</code>：两个下划线开头，声明该属性为私有</li>
<li><code>__private_method</code>：两个下划线开头，声明该方法为私有方法</li>
</ul>

<p>以使用 <code>object._className__attrName</code>访问私有属性，不能这样访问函数。</p>

<pre><code class="language-python">class Runoob:
    __site = &quot;www.runoob.com&quot;

runoob = Runoob()
print runoob._Runoob__site
-------------
&gt;&gt;www.runoob.com
</code></pre>

<h5 id="toc_7">下划线</h5>

<ul>
<li><code>__NAME__</code>:：定义的是特殊方法，一般是系统定义名字 ，类似 <code>__init__()</code> 之类的。</li>
<li><code>_NAME</code>：protected </li>
<li><code>__NAME</code>：private</li>
</ul>

<h5 id="toc_8">SQL</h5>

<pre><code class="language-python">import MySQLdb

# 打开数据库连接
db = MySQLdb.connect(&quot;localhost&quot;, &quot;testuser&quot;, &quot;test123&quot;, &quot;TESTDB&quot;, charset=&#39;utf8&#39; )

# 使用cursor()方法获取操作游标 
cursor = db.cursor()

# 使用execute方法执行SQL语句
cursor.execute(&quot;SELECT VERSION()&quot;)

# 使用 fetchone() 方法获取一条数据
data = cursor.fetchone()

sql = &quot;SELECT * FROM EMPLOYEE \
       WHERE INCOME &gt; &#39;%d&#39;&quot; % (1000)
try:
   # 执行SQL语句
   cursor.execute(sql)
   # 获取所有记录列表
   results = cursor.fetchall()
   for row in results:
      fname = row[0]
      lname = row[1]
      age = row[2]
      sex = row[3]
      income = row[4]
      # 打印结果
      print &quot;fname=%s,lname=%s,age=%d,sex=%s,income=%d&quot; % \
             (fname, lname, age, sex, income )
except:
   print &quot;Error: unable to fecth data&quot;

#提交修改
db.commit()

#回滚
db.rollback()

# 关闭数据库连接
db.close()
</code></pre>

<h5 id="toc_9">多线程</h5>

<h6 id="toc_10">thread模块</h6>

<p>级别较低</p>

<pre><code class="language-python">import thread
 
# 为线程定义一个函数
def func(a, b):
   ...
 
# 创建两个线程
try:
   thread.start_new_thread( func, (&quot;a&quot;, 1, ) )
   thread.start_new_thread( func, (&quot;b&quot;, 2, ) )
except:
   print &quot;Error: unable to start thread&quot;
</code></pre>

<h6 id="toc_11">threading</h6>

<p>直接从<code>threading.Thread</code>继承，然后重写<code>__init__</code>方法和<code>run</code>方法。</p>

<pre><code class="language-python"> 
import threading
import time
 
exitFlag = 0
 
class myThread (threading.Thread):   
    def __init__(self):
        threading.Thread.__init__(self)
        
    def run(self):                  
        ...
 
# 创建新线程
thread1 = myThread()
thread2 = myThread()
 
# 开启线程
thread1.start()
thread2.start()
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一些思考]]></title>
    <link href="neillee1991.github.io/15239450451854.html"/>
    <updated>2018-04-17T14:04:05+08:00</updated>
    <id>neillee1991.github.io/15239450451854.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">20180417</h4>

<ul>
<li>战胜市场实在是too damn hard，市场好的时候赚钱很容易，市场不好的时候，钱亏得更快，所以不要妄想要战胜市场了，能够紧跟市场就已经非常了不起了</li>
<li>炒股需要耐心，所以不能以一种赚钱的心态来炒股。扔一些闲散的钱进去可以保证自己不会太急躁太焦虑，急躁和焦虑会影响判断。尽管随着资金流动市场或者股票会有短期的波动，但是长期来看，好的公司还是能够稳稳地拿到收益的。</li>
<li>尽量不要满仓。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RE:start]]></title>
    <link href="neillee1991.github.io/15218074113596.html"/>
    <updated>2018-03-23T20:16:51+08:00</updated>
    <id>neillee1991.github.io/15218074113596.html</id>
    <content type="html"><![CDATA[
<p>今天想了一下，觉得还是把博客开回来比较好，毕竟可以坚持一段时间写写东西是一个很好的习惯。</p>

<p>上次的博客我想要弄成一个非常偏技术，很hard core的东西，给人看起来比较炫酷。但是实践证明这样真的蛮累的，我把大量的时间放在了格式、美观上，完全没法专心于内容本身。所以以后就随便写点啥吧。记录一下自己的学习心得，炒股时的感受，最近看的书。</p>

<p>最近心态发生了很大的变化，对一些事情的看法发生了改变。以前我会把技术看的很重，觉得只要有精巧的模型，一切问题都可以被解决。我想如果我有一个模拟市场上每个交易员行为的模型，我用随机的方法产生很多交易员，就可以精确的模拟出股价的波动，这有一点拉普拉斯妖的感觉。但是现在我觉得技术、非常细枝末节的东西反而并不是最重要的，一些形而上、思想形态的东西反而起到决定作用。同样的，我以前觉得哲学好像是非常虚的东西，而现在看来，这些高屋建瓴的东西，其实反而更应该被重视。</p>

]]></content>
  </entry>
  
</feed>
